
# vim

[vim日本語ドキュメント](https://vim-jp.org/vimdoc-ja/)

★ Help参照
```
:help
:help usr_xx
```

<br>

## Concept
**ヤンクしたデータとexコマンドを組み合わせて、入力を自動化したものをmapで割り当てる**<br>
**使用頻度が高く、利用価値の高いコマンドを .vimrc に map しておく**

★カーソル位置の文字列を取得<br>
現在のカーソル位置の文字列（単語）をヤンク<br>
```
yiw
```

exコマンドで、`Ctrl+r`の後に、`”`を入力
（現在のカーソル位置の文字列をコピーして、、、続けてexコマンドで何かを行う）
```
:<C-r>”
```

検索した文字列の取得
```
:<C-r>/
```

上記を利用して、新規コマンドを作成（ヤンクしたデータの取得 + exコマンド）

<br>

★ 大量のコードをどうやって読み書きするか？（all.txt ）<br>
あらかじめ自分の見るべきファイルをリストアップしておく<br>
このリストされたファイル(all.txt)経由で、見たいファイル(*.c, *.h)を開く<br>
ターミナルから `vim xx/yy/zz.c` などとはいちいちやらない！<br>
**このリスト化されたファイルの一覧をtag-jump, grep の対象とする（IDEのワークスペース）**<br>
膨大なディレクトリ群から見るべき対象を絞り込み、一覧を生成する。[生成方法](https://github.com/dogdio/fbt/blob/master/vim/bin/All.sh)は何でもOK。<br>
ディレクトリ名が長い場合は、フォルダを掘って、その中からシンボリックリンクを使う<br>
自分の担当範囲と共通ライブラリ、下位層、上位層当たりを一覧にしておく<br>
```
$ find dir1/ -name “*.[ch]”  > all.txt
$ find dir2/ -name “*.cpp”  >> all.txt
```

```
関係するコードは全てall.txtに記載し、ボタン一発でgrep, tag-jumpできるようにする
  [UpperLayer]
       ↓
  [  My Code ] <--> [Common Library]
       ↓
  [UnderLayer]
```

all.txtを開いて、縦分割 `vs` する<br>
自分が開きたいファイルをvim上で検索する。`/file<CR>` とすることで、目標物に素早くたどり着く。<br>
ファイルブラウザ、コンソール画面からファイルを探す必要は無い。<br>
カーソルを左において、`Ctrl+f`でファイルを右側に開く（左側には一覧がキープされる）<br>
左側に開く場合は、`Shift+f` 、hoge.c を見ているときに、all.txtに戻るときは、`Shift-A`
```
$ vim all.txt
:vs
/hoge.c
```

```
" .vimrc
map <C-f> 0y$<C-w>l:open <C-r>"<CR>
map F 0y$:open <C-r>"<CR>
map A :open all.txt<CR>
```

![vim1](https://github.com/dogdio/fbt/blob/for_img/img/vim1.png "all.txt")

「左側に一覧`all.txt`、右側にコード`Lock.h`」、のように並べて表示すると見やすくなる<br>
grep結果は右側の下半分に表示される（詳細は後述）<br>
左側でメモをとりつつ、右側にコードを表示するということもできる<br>
all.txt に新しいファイル名を追記して、`Ctrl+f`で新規ファイルとしてオープンできる<br>

★ カーソル位置のファイルを開く<br>
`gf`でカーソル位置のファイルを開くことができる。上記の`F`と同じ。<br>
systemのインクルードファイル(stdio.h, unistd.hなど)を`gf`で開くことができる<br>
（後述の、`Ctrl+b`で戻れる）<br>
`Ctrl+w gf` で新しいタブでファイルを開く。`Ctrl+w f` だと水平分割して開く<br>

★ all.txt を新しいタブで再度開く<br>
**新しいタブを開いて、all.txt を開いて、新しいファイルを開く、、、これは何度も繰り返される作業なので、ボタン一発で出来た方がよい**<br>
`Ctrl+a`により、`新しいタブの左側にall.txt, 右側に現在のファイルが再表示` される

```
map <C-a> mA:tabnew all.txt<CR>:vs<CR><C-W>25<<C-W>l'Azz
```
  
このコマンドは、`あるファイルを参照しているときに、現在のポジションをキープしたまま、同ファイル内の別の箇所を参照する` という目的にも使える。<br>
上記の`Ctrl+a`で新しいタブを開いた場合、`:lopen`すると、location-listは継承されるが、以前のタブとは別物として扱うことが出来る

<br>

## Move, Search
★ カーソルの移動、タブの移動、マウス<br>
上`k`, 下`j`, 左`h`, 右`l` のキーバインディングを、タブ、ウィンドウの移動にも適用する<br>
`Ctrl+l` で左のタブ、`Ctrl+h` で右のタブに移動する<br>
新しいタブでファイルを開くときは、`:tabnew hoge.c` 
```
map <C-l> :tabnext<CR>
map <C-h> :tabprev<CR>
```

縦に分割する場合は、`:vs`, 水平に分割する場合は`:sp`<br>
`Ctrl+j`で分割したウィンドウの下、`Ctrl+k`で上に移動する<br>
（Ctrl+wを省くだけだが楽になる）
`Ctrl+w h`, `Ctrl+w l` で縦分割したウィンドウを左右に移動する
```
map <C-j> <C-w>j
map <C-k> <C-w>k
```

マウスでクリックした位置にカーソル移動する（タブも選択できる）<br>
```
set mouse=a
```

TeraTermで文字列を選択時にコピペをしたい場合は、`:set mouse= `にすることでコピーできるようになる<br>
(この状態だとクリック位置にカーソルは合わない）

分割したウィンドウの幅調整<br>
`F9`, `F10`で縦幅、`F11`, `F12`で横幅を調整する
（縦幅調整後はカーソルは下ウィンドウ、横幅調整後は右ウィンドウになる）
```
map <F9> <C-j><C-W>3+
map <F10> <C-j><C-W>3-
map <F11> <C-w>l<C-W>3>
map <F12> <C-w>l<C-W>3<
```

ファイルの先頭 `gg`、ファイルの末尾`G`、行の先頭`0`、行の末尾`$`に移動<br>
関数の先頭に後方移動 `{{`、前方移動 `}}`<br>
対応する括弧、#if ~ #endif に移動 `%`<br>


★ 以前のカーソル位置に戻る、進む<br>
デフォルトは `o, i` だがやや覚えにくいので、割り当てを変えている。<br>
既存コマンドを再割り当てするときは、noremapを使う<br>
戻るとき(back)は`Ctrl+b`、進む(next)ときは、`Ctrl+n`
```
noremap <C-b> <C-o>
noremap <C-n> <C-i>
```

ファイルを開いたときに以前のカーソル位置を復旧させる
```
:au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
```

★ 検索<br>
カーソル位置で `*`で、単語の境界有りで前方検索。`n` で続けて前方検索、`N`だと後方検索<br>
単語境界有りの場合は、`/\<hoge\>` のように、括る

<br>

検索した文字の色づけのON/OFF
```
set hlsearch
set nohlsearch
```

インクリメンタル検索しない
```
set noincsearch  
```

大文字小文字を区別して検索する
```
set noignorecase
```

現在のカーソル位置から、単語の末尾までを検索対象とする、`Shift+y`
```
map Y ye/<C-R>"<CR>
```

現在のハイライトを非表示にする、`q`
```
map q :noh<CR>
```

前回検索した文字に加えて新たな検索文字として、カーソル位置のワードをORで追加する、`F3`<br>
複数のキーワードをハイライト表示したいときに使用する<br>
ハイライトされるキーワードは全てのタブ、ウィンドウで同じである<br>
```
map <F3> yiw/<Up>\\|\<<C-R>"\><CR>
```

左側のカーソル位置にある単語を、右側で検索する、`F7`<br>
`F8` と使用方法はほぼ同じ。`F7`の後に、`n`を連打で、検索を継続できる<br>
関数定義ではなく、関数の参照箇所を検索する場合はこちらのほうがよい<br>
```
map <F7> yiw<C-w>l/\<<C-R>"\><CR>
```

★ tag-jump<br>
all.txt が存在するディレクトリに、tagsファイルを生成しておく。<br>
（all.txtに含まれるファイル全てをtagsの対象とする）
```
$ ctags `cat all.txt`
$ vim all.txt
```

tag-jumpする場合は、`Ctrl+]`、戻る場合は`Ctrl+T`<br>
画面を水平に分割しつつtag-jumpをするときは、`Ctrl+w Ctrl+]`<br>
`zz`で中央に表示する
```
map <C-t> <C-t>zz
map <C-]> <C-]>zz
```

指定したキーワードに対して、tag-jumpをする<br>
名前はTABで補完可能。stagだと画面分割有り（vtagはない）<br>
```
:tag hoge_func
:tag hoge_ --> このあとTABで補完できる
:stag hoge_func
```

tag-jump先が複数ある場合（同じ名前の定義が複数存在する）
```
<Ctrl+]>
:ts
番号を選択して、<Enter>
```

タグファイルを更新する、`Shift+T`
```
map T :!ctags `cat all.txt`<CR>
```

新しいタブを開いてtag-jumpする、`Ctrl+o`
```
map <C-o> yiw:tabnew <CR>:tag <C-R>"<CR>zz
```

現在のカーソル位置から単語末尾までに対して、tag-jumpする、`Ctrl+y`
（関数の前のアンダースコアなどのプレフィックスが邪魔な時）
```
map <C-y> ye:tag <C-R>"<CR>zz
```

★ **縦分割状態で、左側のキーワードを右側でtag-jumpして開く**、`F8`<br>
左側でメモファイル、ヘッダファイルを開きつつ、右側でソースを開く、のように使える。<br>
または、`左側が関数の呼び出し側、右側が呼び出される側` のようにすると非常に見やすい。<br>
（名前が長すぎてコードが横長になってしまうと縦分割がやりにくいのでほどほどの長さにすること）
```
map <F8> yiw<C-W>l:tag <C-R>"<CR>zz
```

### 注意
```
tag-jump出来ない場合は、all.txt とは別ファイルで定義されている、もしくは糞マクロにより定義部がパースできていない、
外部のライブラリに定義がある、、等が考えられる。
マクロが原因の場合は、そのようなマクロは避けた方がいい（関数の定義部分をマクロにしちゃう、、）。
基本的に、ctagsでパースできないようなコードは書くべきでは無い（メリットよりもデメリットの方が多い）
```



